worker_processes {{nginx.workers}};

daemon off;

{{#_user?}}
user {{../user}} {{../group}};
{{/_user?}}

pid {{run_dir}}/router-nginx.pid;

events {
  worker_connections {{nginx.worker_connections}};
}

error_log stderr;

env API_UMBRELLA_CONFIG;

http {
  access_log {{log_dir}}/router-access.log combined buffer=32k flush=10s;

  client_body_temp_path {{tmp_dir}}/router-nginx-client_body_temp;
  proxy_temp_path {{tmp_dir}}/router-nginx-proxy_temp;
  fastcgi_temp_path {{tmp_dir}}/router-nginx-fastcgi_temp;
  uwsgi_temp_path {{tmp_dir}}/router-nginx-uwsgi_temp;
  scgi_temp_path {{tmp_dir}}/router-nginx-scgi_temp;
  server_tokens off;

  resolver 127.0.0.1:{{dnsmasq.port}};
  resolver_timeout 12s;

  lua_package_path '{{gatekeeper.dir}}/src/?.lua;{{gatekeeper.dir}}/vendor/share/lua/5.1/?.lua;{{gatekeeper.dir}}/vendor/share/lua/5.1/?/init.lua;;';
  lua_package_cpath '{{gatekeeper.dir}}/vendor/lib/lua/5.1/?.so;;';
  #lua_code_cache off;

  lua_shared_dict stats 10m;
  lua_shared_dict api_users 10m;
  lua_shared_dict config 1m;
  lua_shared_dict resolved_hosts 1m;
  lua_shared_dict apis 5m;
  lua_shared_dict my_locks 100k;
  lua_shared_dict locks 5M;
  lua_shared_dict logs 10m;

  geo $banned_ip {
    default 0;
    {{#ban.ips}}
    {{.}} 1;
    {{/ban.ips}}
  }

  map $http_user_agent $banned_user_agent {
    default 0;
    {{#ban.user_agents}}
    "{{.}}" 1;
    {{/ban.user_agents}}
  }

  init_by_lua_file '{{gatekeeper.dir}}/src/api-umbrella/proxy/hooks/init.lua';
  init_worker_by_lua_file '{{gatekeeper.dir}}/src/api-umbrella/proxy/hooks/init_worker.lua';


  #proxy_cache_path /tmp/nginx-cache levels=1:2 keys_zone=backcache:8m max_size=50m;
  #proxy_cache backcache;
  #proxy_cache_lock on;
  #proxy_cache_key "$scheme$request_method$host$request_uri$is_args$args";
  #add_header X-Cache $upstream_cache_status;
  #proxy_cache_valid 5m;

  lua_check_client_abort on;
  if_modified_since off;

  include ./mime.conf;
  include ./realip.conf;

  # Allow any sized uploads to backends.
  client_max_body_size 0;

  keepalive_timeout 30s;

  gzip on;
  gzip_comp_level 2;
  gzip_disable msie6;
  gzip_min_length 1000;
  gzip_proxied any;
  gzip_types application/atom+xml application/javascript application/json application/rss+xml application/x-javascript application/xml text/css text/csv text/javascript text/plain text/xml;
  gzip_vary on;

  upstream api_umbrella_web_backend {
    server {{web.host}}:{{web.port}};
    keepalive 10;
  }

  upstream api_umbrella_static_site_backend {
    server {{static_site.host}}:{{static_site.port}};
    keepalive 10;
  }

  upstream api_umbrella_varnish_backend {
    server {{varnish.host}}:{{varnish.port}};
    keepalive 10;
  }

  upstream api_umbrella_trafficserver_backend {
    server {{trafficserver.host}}:{{trafficserver.port}};
    keepalive 10;
  }

  dyups_trylock on;
  dyups_read_msg_timeout 300ms;
  server {
    listen 8081;
    location / {
      dyups_interface;
    }
  }

  server {
    listen 14008;
    location /api-umbrella/v1/health {
      content_by_lua_file '{{gatekeeper.dir}}/src/api-umbrella/http-api/health.lua';
    }

    location /api-umbrella/v1/state {
      content_by_lua_file '{{gatekeeper.dir}}/src/api-umbrella/http-api/state.lua';
    }
  }

  {{#primary_hosts}}
  # Primary host. Serves up both APIs and web content.
  server {
    listen {{../http_port}}{{#default}} default_server{{/default}};
    #listen [::]:{{../http_port}}{{#default}} default_server{{/default}};
    server_name {{hostname}};

    listen {{../https_port}} ssl{{#default}} default_server{{/default}};
    #listen [::]:{{../https_port}} ssl{{#default}} default_server{{/default}};
    {{#ssl_cert}}
    ssl_certificate {{ssl_cert}};
    ssl_certificate_key {{ssl_cert_key}};
    {{/ssl_cert}}
    {{^ssl_cert}}
    ssl_certificate {{../../etc_dir}}/ssl/self_signed.crt;
    ssl_certificate_key {{../../etc_dir}}/ssl/self_signed.key;
    {{/ssl_cert}}

    include ./frontend_defaults.conf;

    # Determine the SSL status when it's passed via X-Forwarded-Proto from the
    # SSL terminator.
    set $ssl_status "off";
    if ($server_port = {{../https_port}}) {
      set $ssl_status "on";
    }

    if ($http_x_forwarded_proto = "https") {
      set $ssl_status "on";
    }

    # Match any required HTTPS-only pages.
    if ($uri ~ ^/(account|admin|admins|signup)(/|$)) {
      set $ssl_status "${ssl_status}_required";
    }

    # Force certain content to HTTPS-only.
    if ($ssl_status = "off_required") {
      rewrite ^ https://$host:{{../https_port}}$request_uri? permanent;
    }

    # Route the docs and other static pages to the Rails web app. This may
    # change, so that's why we're treating it separately.
    location ~* ^/(|about|assets|community|contact|developer|doc|docs|metrics|favicon\.ico|images|robots.txt|signup|static|__middleman|__rack)(/|$) {
      {{#../static_site.host_header}}
      set $proxy_host_header "{{../../static_site.host_header}}";
      {{/../static_site.host_header}}
      include ./frontend_proxy_header_defaults.conf;
      proxy_pass http://api_umbrella_static_site_backend;
    }

    # Route the dynamic portions of the site to the Rails web app.
    location ~* ^/(admin|admins|web-assets)(/|$) {
      include ./frontend_proxy_header_defaults.conf;
      proxy_pass http://api_umbrella_web_backend;
    }

    # Route all other requests as APIs going through the API Umbrella Gatekeeper.
    location / {
      include ./frontend_proxy_header_defaults.conf;
      include ./gatekeeper.conf;
    }
  }
  {{/primary_hosts}}

  {{#secondary_hosts}}
  # Secondary host. Serves up only API traffic (no web page content).
  server {
    listen {{http_port}};
    #listen [::]:{{http_port}};
    server_name {{hostname}};

    {{#ssl_cert}}
    listen {{../../https_port}} ssl;
    #listen [::]:{{../../https_port}} ssl;
    ssl_certificate {{ssl_cert}};
    ssl_certificate_key {{ssl_cert_key}};
    {{/ssl_cert}}

    include ./frontend_defaults.conf;

    # Route all other requests as APIs going through the API Umbrella Gatekeeper.
    location / {
      include ./frontend_proxy_header_defaults.conf;
      include ./gatekeeper.conf;
    }
  }
  {{/secondary_hosts}}

  {{^has_default_host}}
  # Catch-all host. Serves up only API traffic (no web page content).
  # Like secondary hosts, but minus HTTPS (since we don't know the domain).
  server {
    listen {{http_port}} default_server;
    #listen [::]:{{http_port}} default_server;
    server_name _;

    include ./frontend_defaults.conf;

    # Route all other requests as APIs going through the API Umbrella Gatekeeper.
    location / {
      include ./frontend_proxy_header_defaults.conf;
      include ./gatekeeper.conf;
    }
  }
  {{/has_default_host}}

  {{^development_env}}
  server {
    listen {{static_site.port}};
    #listen [::]:{{static_site.port}};
    server_name _;
    port_in_redirect off;

    root {{static_site.build_dir}};
  }
  {{/development_env}}

  map $http_accept_encoding $normalized_accept_encoding {
    "~(^|,) *gzip *; *q=0[\.0]* *($|,)" "";
    "~(^|,) *gzip *($|,|;)" gzip;
    default "";
  }

  server {
    listen {{router.api_backends.port}};
    #listen [::]:{{router.api_backends.port}};
    server_name _;

    set $x_api_umbrella_request_id $http_x_api_umbrella_request_id;
    log_by_lua_file '{{gatekeeper.dir}}/src/api-umbrella/proxy/hooks/log_api_backend_proxy.lua';

    # Enable keep alive connections to the backend servers.
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    proxy_set_header Host $http_x_api_umbrella_backend_host;
    proxy_set_header X-Api-Umbrella-Backend-Scheme "";
    proxy_set_header X-Api-Umbrella-Backend-Host "";
    proxy_set_header X-Api-Umbrella-Backend-Id "";

    # Only retry backends in the event of connection errors (and not also
    # connection timeouts as is the default). This prevents slow backend timeouts
    # triggering multiple requests if multiple backends are defined.
    proxy_next_upstream error;

    # Don't buffer proxied requests to allow for streaming APIs.
    proxy_buffering off;

    # If the backend only returns gzipped responses, decompress them as
    # appropriate to meet the Accept headers of the current client.
    gunzip on;

    location / {
      proxy_pass $http_x_api_umbrella_backend_scheme://api_umbrella_${http_x_api_umbrella_backend_id}_backend;
    }
  }
}
